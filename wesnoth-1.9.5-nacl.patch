diff --git a/SConstruct b/SConstruct
index ff91c69..b576929 100755
--- a/SConstruct
+++ b/SConstruct
@@ -282,6 +282,15 @@ if env["prereqs"]:
     conf.CheckLib("m")
     conf.CheckFunc("round")
 
+    if env['host'] in ['x86_64-nacl', 'i686-nacl']:
+#      env.Append(LINKFLAGS = ['-static', '-T',  'ldscripts/elf64_nacl.x.static'])
+      env.Append(LINKFLAGS = ['-Wl,--undefined=_ZN2pp12CreateModuleEv'])
+      env.Append(LIBS = ['-lpthread', '-lSDL', '-ldl', '-lppapi', '-lppapi_cpp',
+                         '-lnacl-mounts', '-ljpeg',
+                         '-lpng', '-ltiff', '-lexpat', '-lpixman-1',
+                         '-lvorbisfile', '-lvorbis', '-logg', '-lmikmod'
+                         ])
+
     have_server_prereqs = \
         conf.CheckCPlusPlus(gcc_version = "3.3") and \
         conf.CheckGettextLibintl() and \
@@ -349,6 +358,11 @@ else:
     test_env = env.Clone()
     client_env = env.Clone()
 
+
+if env['host'] in ['x86_64-nacl', 'i686-nacl']:
+  env['_LIBFLAGS'] = '-Wl,--start-group ' + env['_LIBFLAGS'] + ' -Wl,--end-group'
+  client_env['_LIBFLAGS'] = '-Wl,--start-group ' + client_env['_LIBFLAGS'] + ' -Wl,--end-group'
+
 have_msgfmt = env["MSGFMT"]
 if not have_msgfmt:
      env["nls"] = False
@@ -362,7 +376,7 @@ if not env['nls']:
 #
 
 for env in [test_env, client_env, env]:
-    env.Append(CPPPATH = ["#/", "#/src"])
+    env.Prepend(CPPPATH = ["#/", "#/src"])
 
     env.Append(CPPDEFINES = ["HAVE_CONFIG_H"])
 
@@ -433,7 +447,7 @@ else:
         env["svnrev"] = ""
 
 Export(Split("env client_env test_env have_client_prereqs have_server_prereqs have_test_prereqs"))
-SConscript(dirs = Split("po doc packaging/windows"))
+SConscript(dirs = Split("po doc packaging/windows ppapi"))
 
 binaries = Split("wesnoth wesnothd cutter exploder campaignd test")
 builds = {
diff --git a/build.sh b/build.sh
new file mode 100755
index 0000000..495fa86
--- /dev/null
+++ b/build.sh
@@ -0,0 +1,11 @@
+#!/bin/bash
+set -e -x
+
+ROOT=${NACL_TOOLCHAIN_ROOT:-$HOME/root/nacl-sdk}
+PATH=$ROOT/bin:$ROOT/x86_64-nacl/usr/bin:$PATH
+
+PKG_CONFIG_PATH=$ROOT/x86_64-nacl/usr/lib/pkgconfig scons -j15 host=x86_64-nacl \
+  boostdir=$ROOT/x86_64-nacl/usr/include/boost \
+  boostlibdir=$ROOT/x86_64-nacl/usr/lib sdldir=$ROOT/x86_64-nacl/usr nls=no \
+  destdir=$ROOT/x86_64-nacl \
+  build=release wesnoth # install
diff --git a/build32.sh b/build32.sh
new file mode 100755
index 0000000..c51819c
--- /dev/null
+++ b/build32.sh
@@ -0,0 +1,11 @@
+#!/bin/bash
+set -e -x
+
+ROOT=${NACL_TOOLCHAIN_ROOT:-$HOME/root/nacl-sdk}
+PATH=$ROOT/bin:$ROOT/i686-nacl/usr/bin:$PATH
+
+PKG_CONFIG_PATH=$ROOT/i686-nacl/usr/lib/pkgconfig scons -j15 host=i686-nacl \
+  boostdir=$ROOT/i686-nacl/usr/include/boost \
+  boostlibdir=$ROOT/i686-nacl/usr/lib sdldir=$ROOT/i686-nacl/usr nls=no \
+  destdir=$ROOT/i686-nacl \
+  build=release wesnoth # install
diff --git a/buildpack.py b/buildpack.py
new file mode 100755
index 0000000..da1e37f
--- /dev/null
+++ b/buildpack.py
@@ -0,0 +1,139 @@
+#!/usr/bin/python
+
+import shutil
+import glob
+import os
+import fnmatch
+import sys
+
+
+# pack description format: [root_mask, file_name_mask, file_path_exclusion_mask]
+# pack will contain 
+#   all files under (and including) the expansion of root_mask,
+#   whose names match file_name_mask,
+#   whose full path (with root_mask) does not match full_path_exclusion_mask
+pack0_masks = [
+    ['data/languages', '*', ''],
+    ['data/hardwired', '*', ''],
+    ['images/game-icon.png', '*', ''],
+    ['images/cursors-bw', '*', ''],
+    ['images/misc/logo.png', '*', ''],
+    ]
+
+pack1_masks = [
+    ['images', '*', ''],
+    ['data/*.cfg', '*', ''],
+    ['data/gui', '*', ''],
+    ['data/themes', '*.cfg', ''],
+    ['data/core', '*.cfg', ''],
+    ['data/COPYING.txt', '*', ''],
+    ['data/core/images/maps/wesnoth.png', '*', ''],
+    ['data/ai', '*', ''],
+    ['data/campaigns', '_main.cfg', ''],
+    ['sounds/button.wav', '*', ''],
+    ['sounds/select.wav', '*', ''],
+    ]
+
+# These files are needed to display the campaign list.
+pack2_masks = [
+    ['data/core/images/misc', '*', ''],
+    ['data/campaigns', 'campaign_image.png', ''],
+    ['data/campaigns', 'campaign_image.jpg', ''],
+    ['data/core/images/units/human-loyalists/knight.png', '*', ''],
+    ['data/core/images/units/elves-wood/lord.png', '*', ''],
+    ['data/core/images/units/human-outlaws/fugitive.png', '*', ''],
+    ['data/core/images/units/elves-wood/high-lord.png', '*', ''],
+    ['data/core/images/units/human-loyalists/general.png', '*', ''],
+    ['data/core/images/units/human-magi/elder-mage.png', '*', ''],
+    ['data/core/images/units/undead/soulless-swimmer.png', '*', ''],
+    ['data/core/images/units/orcs/ruler.png', '*', ''],
+    ['data/campaigns/Heir_To_The_Throne/images/units/konrad-lord-leading.png', '*', ''],
+    ['data/campaigns/The_South_Guard/images/deoran/horseman-commander-defend.png', '*', ''],
+    ['data/campaigns/Descent_Into_Darkness/images/units/dark-mage.png', '*', ''],
+    ['data/campaigns/The_Rise_Of_Wesnoth/images/units/noble-lord.png', '*', ''],
+    ['data/campaigns/Under_the_Burning_Suns/images/units/elves-desert/kaleh.png', '*', ''],
+    ['data/core/images/items/hammer-runic.png', '*', ''],
+    ['data/core/images/items/sceptre-of-fire.png', '*', ''],
+    ['data/core/images/scenery/dwarven-doors-closed.png', '*', ''],
+    ]
+
+pack3_masks = [
+    ['data', '*.cfg', ''],
+    ['data/core/images/terrain', '*', ''],
+    ['data/core/images/themes', '*', ''],
+    ['data/core/sounds', '*', ''],
+    ['data/lua', '*', ''],
+    ['sounds', '*', ''],
+    ]
+
+packs = [pack0_masks, pack1_masks, pack2_masks, pack3_masks]
+
+
+all_files = set()
+
+def list_path_with_mask(path, mask, exclude_mask):
+    files = set()
+    if os.path.isdir(path):
+        for (dirpath, dirnames, filenames) in os.walk(path):
+            for filename in filenames:
+                if fnmatch.fnmatch(filename, mask) and not fnmatch.fnmatch(os.path.join(dirpath, filename), exclude_mask):
+                    files.add(os.path.join(dirpath, filename))
+    else:
+        if fnmatch.fnmatch(path, mask) and not fnmatch.fnmatch(path, exclude_mask):
+            files.add(path)
+        
+    return files
+
+def list_pack_contents(masks):
+    files = set()
+    for (root_path, mask, exclude_mask) in masks:
+        roots = glob.glob(root_path)
+        for root in roots:
+            new_files = list_path_with_mask(root, mask, exclude_mask).difference(all_files)
+            files.update(new_files)
+            all_files.update(new_files)
+    return files
+
+
+def build_pack(files, out):
+    fout = open(out, "w") 
+    out_list = []
+    sz = 0
+    for f in files:
+        data = open(f).read()
+        fout.write(data)
+        out_list.append('{"/%s", "/%s", %d},\n' % (f, out, sz))
+        sz += len(data)
+    fout.close()
+    print '%s: %d files, %d bytes total' % (out, len(files), sz)
+
+    return ''.join(out_list)
+
+
+
+base_dir = sys.argv[1]
+out_list = os.path.abspath(sys.argv[2])
+os.chdir(base_dir)
+
+# define additional packs
+
+packs.append([['data/core/images/units', '*', ''], ['data/core/images/attacks', '*', '']])
+
+for path in glob.glob(os.path.join(base_dir, 'data/campaigns/*')):
+    path = path[len(base_dir):]
+    print 'Campaign: ' + path
+    packs.append([[path, '*', '']])
+
+packs.append([['data/core/images/portraits', '*', '']])
+packs.append([['data/core/images', '*', '']])
+packs.append([['data', '*', 'data/core/music/*']])
+
+
+# build packs
+fout_list = open(out_list, 'w')
+for (index, pack) in enumerate(packs):
+    pack_files = list_pack_contents(pack)
+    out_list_data = build_pack(pack_files, 'pack' + str(index))
+    fout_list.write(out_list_data)
+fout_list.write('{"", "", 0}\n')
+fout_list.close()
diff --git a/check_browser.js b/check_browser.js
new file mode 100644
index 0000000..9636ad0
--- /dev/null
+++ b/check_browser.js
@@ -0,0 +1,178 @@
+/*
+ * Copyright (c) 2011 The Native Client Authors. All rights reserved.
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+/**
+ * @fileoverview This file provides a BrowserChecker Javascript class.
+ * Users can create a BrowserChecker object, invoke checkBrowser(|version|),
+ * and then use getIsValidBrowser() and getBrowserSupportStatus()
+ * to determine if the browser version is greater than |version|
+ * and if the Native Client plugin is found.
+ */
+
+// Create a namespace object
+var browser_version = browser_version || {};
+
+/**
+ * Class to provide checking for version and NativeClient.
+ * @param {integer} arg1 An argument that indicates major version of Chrome we
+ *     require, such as 14.
+ */
+
+/**
+ * Constructor for the BrowserChecker.  Sets the major version of
+ * Chrome that is required to |minChromeVersion|.
+ * @param minChromeVersion   The earliest major version of chrome that
+ *     is supported.  If the Chrome browser version is less than
+ *     |minChromeVersion| then |isValidBrowswer| will be set to false.
+ * @param opt_maxChromeVersion   Ignored.  Retained for backwards compatibility.
+ * @param appVersion  The application version string.
+ * @param plugins     The plugins that exist in the browser.
+ * @constructor
+ */
+browser_version.BrowserChecker = function(minChromeVersion,
+                                          appVersion, plugins,
+                                          opt_maxChromeVersion) {
+  /**
+   * Version specified by the user. This class looks to see if the browser
+   * version is >= |minChromeVersion_|.
+   * @type {integer}
+   * @private
+   */
+  this.minChromeVersion_ = minChromeVersion;
+
+  /**
+   * List of Browser plugin objects.
+   * @type {Ojbect array}
+   * @private
+   */
+  this.plugins_ = plugins;
+
+  /**
+   * Application version string from the Browser.
+   * @type {integer}
+   * @private
+   */
+  this.appVersion_ = appVersion;
+
+  /**
+   * Flag used to indicate if the browser has Native Client and is if the
+   * browser version is recent enough.
+   * @type {boolean}
+   * @private
+   */
+  this.isValidBrowser_ = false;
+
+  /**
+   * Actual major version of Chrome -- found by querying the browser.
+   * @type {integer}
+   * @private
+   */
+  this.chromeVersion_ = null;
+
+  /**
+   * Browser support status. This allows the user to get a detailed status
+   * rather than using this.browserSupportMessage.
+   */
+  this.browserSupportStatus_ =
+      browser_version.BrowserChecker.StatusValues.UNKNOWN;
+}
+
+/**
+ * The values used for BrowserChecker status to indicate success or
+ * a specific error.
+ * @enum {id}
+ */
+browser_version.BrowserChecker.StatusValues = {
+  UNKNOWN: 0,
+  NACL_ENABLED: 1,
+  UNKNOWN_BROWSER: 2,
+  CHROME_VERSION_TOO_OLD: 3,
+  NACL_NOT_ENABLED: 4,
+  NOT_USING_SERVER: 5
+};
+
+/**
+ * Determines if the plugin with name |name| exists in the browser.
+ * @param {string} name The name of the plugin.
+ * @param {Object array} plugins The plugins in this browser.
+ * @return {bool} |true| if the plugin is found.
+ */
+browser_version.BrowserChecker.prototype.pluginExists = function(name,
+                                                                 plugins) {
+  for (var index=0; index < plugins.length; index++) {
+    var plugin = this.plugins_[index];
+    var plugin_name = plugin['name'];
+    // If the plugin is not found, you can use the Javascript console
+    // to see the names of the plugins that were found when debugging.
+    if (plugin_name.indexOf(name) != -1) {
+      return true;
+    }
+  }
+  return false;
+}
+
+/**
+ * Returns browserSupportStatus_ which indicates if the browser supports
+ * Native Client.  Values are defined as literals in
+ * browser_version.BrowserChecker.StatusValues.
+ * @ return {int} Level of NaCl support.
+ */
+browser_version.BrowserChecker.prototype.getBrowserSupportStatus = function() {
+  return this.browserSupportStatus_;
+}
+
+/**
+ * Returns isValidBrowser (true/false) to indicate if the browser supports
+ * Native Client.
+ * @ return {bool} If this browser has NativeClient and correct version.
+ */
+browser_version.BrowserChecker.prototype.getIsValidBrowser = function() {
+  return this.isValidBrowser_;
+}
+
+/**
+ * Checks to see if this browser can support Native Client applications.
+ * For Chrome browsers, checks to see if the "Native Client" plugin is
+ * enabled.
+ */
+browser_version.BrowserChecker.prototype.checkBrowser = function() {
+  var versionPatt = /Chrome\/(\d+)\.(\d+)\.(\d+)\.(\d+)/;
+  var result = this.appVersion_.match(versionPatt);
+
+  // |result| stores the Chrome version number.
+  if (!result) {
+    this.isValidBrowser_ = false;
+    this.browserSupportStatus_ =
+        browser_version.BrowserChecker.StatusValues.UNKNOWN_BROWSER;
+  } else {
+    this.chromeVersion_ = result[1];
+    // We know we have Chrome, check version and/or plugin named Native Client
+    if (this.chromeVersion_ >= this.minChromeVersion_) {
+      var found_nacl = this.pluginExists('Native Client', this.plugins_);
+      if (found_nacl) {
+        this.isValidBrowser_ = true;
+        this.browserSupportStatus_ =
+            browser_version.BrowserChecker.StatusValues.NACL_ENABLED;
+      } else {
+        this.isValidBrowser_ = false;
+        this.browserSupportStatus_ =
+            browser_version.BrowserChecker.StatusValues.NACL_NOT_ENABLED;
+      }
+    } else {
+      // We are in a version that is less than |minChromeVersion_|
+      this.isValidBrowser_ = false;
+      this.browserSupportStatus_ =
+          browser_version.BrowserChecker.StatusValues.CHROME_VERSION_TOO_OLD;
+    }
+  }
+  var my_protocol = window.location.protocol;
+  if (my_protocol.indexOf('file') == 0) {
+    this.isValidBrowser_ = false;
+    this.browserSupportStatus_ =
+        browser_version.BrowserChecker.StatusValues.NOT_USING_SERVER;
+  }
+}
+
diff --git a/genfs.sh b/genfs.sh
new file mode 100755
index 0000000..60639f3
--- /dev/null
+++ b/genfs.sh
@@ -0,0 +1,7 @@
+#!/bin/bash
+BASE=$NACL_SDK_ROOT/toolchain/linux_x86/x86_64-nacl
+(cd $BASE/usr/local/share/wesnoth; find -type d) | perl -pe 's/^\.//' | perl -pe 's/^(.*)$/"$1",/' >ppapi/dirs_generated.cc
+echo "" >>ppapi/dirs_generated.cc
+(cd $BASE/usr/local/share/wesnoth; find -type f -printf "%p %s\n") | perl -pe 's/^\.//' | perl -pe 's/^(.*) (\d+)$/{"$1", $2},/' >ppapi/files_generated.cc
+echo '{"", 0}' >>ppapi/files_generated.cc
+
diff --git a/howto b/howto
new file mode 100644
index 0000000..39efb64
--- /dev/null
+++ b/howto
@@ -0,0 +1,6 @@
+rm wesnoth; NACL_SDK_ROOT=$HOME/native_client_sdk_0_6_1118 NACL_TOOLCHAIN_ROOT=$NACL_SDK_ROOT/toolchain/linux_x86 ./build.sh && ~/nativeclient/native_client/scons-out/opt-linux-x86-64/staging/ncval_stubout wesnoth -o ~/native_client_sdk_0_6_1118/toolchain/linux_x86/x86_64-nacl/usr/local/bin/wesnoth
+
+
+NACL_SDK_ROOT=$HOME/native_client_sdk_0_6_1118 NACL_TOOLCHAIN_ROOT=$NACL_SDK_ROOT/toolchain/linux_x86 ./genfs.sh
+
+./buildpack.py ~/native_client_sdk_0_6_1118/toolchain/linux_x86/x86_64-nacl/usr/local/share/wesnoth/ ppapi/packs_generated.cc
diff --git a/ppapi/SConscript b/ppapi/SConscript
new file mode 100644
index 0000000..68aacff
--- /dev/null
+++ b/ppapi/SConscript
@@ -0,0 +1,16 @@
+import commands, os
+from subprocess import Popen, PIPE
+from glob import glob
+
+Import("*")
+
+for env in [test_env, client_env, env]:
+    env.Append(CPPDEFINES = "$EXTRA_DEFINE")
+
+libwesnoth_ppapi_sources = Split("""
+    plugin.cc
+    """)
+
+libwesnoth_ppapi = env.Library("wesnoth_ppapi", libwesnoth_ppapi_sources)
+
+Export("libwesnoth_ppapi")
diff --git a/ppapi/plugin.cc b/ppapi/plugin.cc
new file mode 100644
index 0000000..231ad8a
--- /dev/null
+++ b/ppapi/plugin.cc
@@ -0,0 +1,197 @@
+// Copyright (c) 2011 The Native Client Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include <pthread.h>
+#include <stdio.h>
+#include <stdlib.h>
+
+#include <ppapi/cpp/instance.h>
+#include <ppapi/cpp/module.h>
+#include <ppapi/cpp/rect.h>
+#include <ppapi/cpp/size.h>
+#include <ppapi/cpp/file_system.h>
+
+#include <SDL_video.h>
+extern int wesnoth_main(int argc, char **argv);
+#include <SDL.h>
+#include <SDL_nacl.h>
+
+#include <nacl-mounts/base/KernelProxy.h>
+#include <nacl-mounts/base/MainThreadRunner.h>
+#include <nacl-mounts/http2/HTTP2Mount.h>
+
+
+const char* http_dirs[] = {
+#include "dirs_generated.cc"
+};
+
+struct http_file_info {
+  const char* path;
+  size_t size;
+} http_files[] = {
+#include "files_generated.cc"
+};
+
+struct http_pack_info {
+  const char* path;
+  const char* pack_path;
+  off_t offset;
+} http_packs[] = {
+#include "packs_generated.cc"
+};
+
+
+class PluginInstance : public pp::Instance {
+ public:
+  explicit PluginInstance(PP_Instance instance) : pp::Instance(instance),
+                                                  sdl_main_thread_(0),
+                                                  width_(0),
+                                                  height_(0),
+                                                  progress_handler_(this) {
+    RequestInputEvents(PP_INPUTEVENT_CLASS_MOUSE);
+    RequestFilteringInputEvents(PP_INPUTEVENT_CLASS_KEYBOARD);
+
+    KernelProxy* proxy = KernelProxy::KPInstance();
+    MainThreadRunner* runner = new MainThreadRunner(this);
+
+    fprintf(stderr, "Requesting an HTML5 local persistent filesystem.\n");
+    fflush(stderr);
+    pp::FileSystem* fs = new pp::FileSystem(this, PP_FILESYSTEMTYPE_LOCALPERSISTENT);
+      
+    fprintf(stderr, "Initializing nacl-mounts.\n");
+    fflush(stderr);
+    HTTP2Mount* http2_mount = new HTTP2Mount(runner, "./usr/local/share/wesnoth");
+    http2_mount->SetLocalCache(fs, 350*1024*1024, "/wesnoth0");
+    http2_mount->SetProgressHandler(&progress_handler_);
+ 
+    fprintf(stderr, "Registering known files.\n");
+    fflush(stderr);
+    for (int i = 0; i < sizeof(http_dirs) / sizeof(*http_dirs); ++i) {
+      char* path = (char*)http_dirs[i];
+      if (path && *path)
+        http2_mount->AddDir(path);
+    }
+
+    for (int i = 0; i < sizeof(http_files) / sizeof(*http_files); ++i) {
+      char* path = (char*)http_files[i].path;
+      size_t size = http_files[i].size;
+      if (path && *path)
+        http2_mount->AddFile(path, size);
+    }
+
+    for (int i = 0; i < sizeof(http_packs) / sizeof(*http_packs); ++i) {
+      char* path = (char*)http_packs[i].path;
+      char* pack_path = (char*)http_packs[i].pack_path;
+      off_t offset = http_packs[i].offset;
+      if (path && *path) {
+        fflush(stderr);
+        http2_mount->SetInPack(path, pack_path, offset);
+      }
+    }
+
+    http2_mount->SetInMemory("/fonts/Andagii.ttf", true);
+    http2_mount->SetInMemory("/fonts/DejaVuSans.ttf", true);
+    http2_mount->SetInMemory("/fonts/wqy-zenhei.ttc", true);
+
+    fprintf(stderr, "Mounting the filesystem.\n");
+    fflush(stderr);
+    proxy->mkdir("/usr", 0777);
+    proxy->mkdir("/usr/local", 0777);
+    proxy->mkdir("/usr/local/share", 0777);
+    // The following 2 lines can be removed when nacl-mounts starts intercepting mkdir() calls.
+    proxy->mkdir("/.wesnoth1.9", 0777);
+    proxy->mkdir("/.wesnoth1.9/saves", 0777);
+    int res = proxy->mount("/usr/local/share/wesnoth", http2_mount);
+    if (!res) {
+      fprintf(stderr, "FS initialization success.\n");
+    } else {
+      fprintf(stderr, "FS initialization failure.\n");
+    }
+    fflush(stderr);
+  }
+
+  ~PluginInstance() {
+    if (sdl_main_thread_) {
+      pthread_join(sdl_main_thread_, NULL);
+    }
+  }
+
+  virtual void DidChangeView(const pp::Rect& position, const pp::Rect& clip) {
+    printf("did change view, new %dx%d, old %dx%d\n",
+        position.size().width(), position.size().height(),
+        width_, height_);
+
+    if (position.size().width() == width_ &&
+        position.size().height() == height_)
+      return;  // Size didn't change, no need to update anything.
+
+    if (sdl_thread_started_ == false) {
+      width_ = position.size().width();
+      height_ = position.size().height();
+
+      SDL_NACL_SetInstance(pp_instance(), width_, height_);
+      // It seems this call to SDL_Init is required. Calling from
+      // sdl_main() isn't good enough.
+      // Perhaps it must be called from the main thread?
+      int lval = SDL_Init(SDL_INIT_VIDEO | SDL_INIT_AUDIO);
+      assert(lval >= 0);
+      if (0 == pthread_create(&sdl_main_thread_, NULL, sdl_thread, this)) {
+        sdl_thread_started_ = true;
+      }
+    }
+  }
+
+  bool HandleInputEvent(const pp::InputEvent& event) {
+    SDL_NACL_PushEvent(event);
+    return true;
+  }
+
+  bool Init(int argc, const char* argn[], const char* argv[]) {
+    return true;
+  }
+
+ private:
+  bool sdl_thread_started_;
+  pthread_t sdl_main_thread_;
+  int width_;
+  int height_;
+
+  static void* sdl_thread(void* param) {
+    static char const * argv[] = {"wesnoth", NULL};
+    printf("starting game thread\n");
+    wesnoth_main(1, (char**)argv);
+    return NULL;
+  }
+
+  class ProgressHandler : public HTTP2ProgressHandler {
+  public:
+    pp::Instance* instance_;
+
+    ProgressHandler(pp::Instance* instance) : instance_(instance) {}
+
+    void HandleProgress(std::string& path, int64_t bytes, int64_t size) {
+      char buf[100];
+      snprintf(buf, sizeof(buf), "%llu,%llu", (unsigned long long)bytes,
+          (unsigned long long)size);
+      std::string message = "[\"" + path + "\"," + buf + "]";
+      instance_->PostMessage(message);
+    }
+  };
+
+  ProgressHandler progress_handler_;
+};
+
+class PepperModule : public pp::Module {
+public:
+  // Create and return a PluginInstanceInstance object.
+  virtual pp::Instance* CreateInstance(PP_Instance instance) {
+    return new PluginInstance(instance);
+  }
+};
+
+namespace pp {
+  Module* CreateModule() {
+    return new PepperModule();
+  }
+}  // namespace pp
diff --git a/scons/config_check_utils.py b/scons/config_check_utils.py
index b566791..5484ad5 100644
--- a/scons/config_check_utils.py
+++ b/scons/config_check_utils.py
@@ -14,5 +14,5 @@ def restore_env(env, backup):
 
 def find_include(prefixes, include_file, include_subdir, default_prefixes = True):
     if default_prefixes:
-        prefixes = ["/usr", "/usr/local", "/sw", "/sw/local"] + prefixes
+        prefixes = prefixes + ["/usr", "/usr/local", "/sw", "/sw/local"]
     return [(prefix, include) for prefix in prefixes for include in glob(join(prefix, "include", include_subdir, include_file))]
diff --git a/src/SConscript b/src/SConscript
index 1b61ede..9a01526 100644
--- a/src/SConscript
+++ b/src/SConscript
@@ -461,7 +461,7 @@ for env in [test_env, client_env, env]:
 
 game_cpp = client_env.Object("game.cpp", EXTRA_DEFINE = not env["pool_alloc"] and "DISABLE_POOL_ALLOC" or None);
 
-client_env.WesnothProgram("wesnoth", [game_cpp] + [libwesnoth_extras, libwesnoth_core, libwesnoth_sdl, libwesnoth, env["wesnoth_res"]], have_client_prereqs)
+client_env.WesnothProgram("wesnoth", [game_cpp] + [libwesnoth_extras, libwesnoth_core, libwesnoth_sdl, libwesnoth, libwesnoth_ppapi, env["wesnoth_res"]], have_client_prereqs)
 
 campaignd_sources = Split("""
     server/input_stream.cpp
diff --git a/src/asserts.hpp b/src/asserts.hpp
index 6a499a4..31b2ede 100644
--- a/src/asserts.hpp
+++ b/src/asserts.hpp
@@ -25,7 +25,8 @@
 #define BREAKPOINT() __debugbreak()
 #define WES_HALT() do { BREAKPOINT(); exit(1); } while (false)
 
-#elif defined(__GNUG__) && (defined(__i386__) || defined(__x86_64__))
+#elif defined(__GNUG__) && (defined(__i386__) || defined(__x86_64__)) \
+  && !defined(__native_client__)
 #define BREAKPOINT() asm("int3")
 #define WES_HALT() do { BREAKPOINT(); abort(); } while (false)
 
diff --git a/src/game.cpp b/src/game.cpp
index 580e545..985a976 100644
--- a/src/game.cpp
+++ b/src/game.cpp
@@ -2403,7 +2403,7 @@ void init_custom_malloc();
 }
 #endif
 
-int main(int argc, char** argv)
+int wesnoth_main(int argc, char** argv)
 {
 #ifndef DISABLE_POOL_ALLOC
 	init_custom_malloc();
@@ -2461,4 +2461,3 @@ int main(int argc, char** argv)
 
 	return 0;
 } // end main
-
diff --git a/src/gui/widgets/text.cpp b/src/gui/widgets/text.cpp
index 21bae78..cee3814 100644
--- a/src/gui/widgets/text.cpp
+++ b/src/gui/widgets/text.cpp
@@ -283,6 +283,8 @@ void ttext_::signal_handler_sdl_key_down(const event::tevent event
 		, const Uint16 unicode)
 {
 
+	fprintf(stderr, "sdl_key_down: %d %d %d\n", key, modifier, unicode);
+
 	DBG_GUI_E << LOG_HEADER << ' ' << event << ".\n";
 
 // For copy/paste we use a different key on the MAC. Other ctrl modifiers won't
diff --git a/wesnoth.html b/wesnoth.html
new file mode 100644
index 0000000..a3f5f8f
--- /dev/null
+++ b/wesnoth.html
@@ -0,0 +1,24 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
+          "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
+<html>
+  <head>
+    <title>Wesnoth NativeClient demo</title>
+    <script type="text/javascript" src="check_browser.js"></script>
+  </head>
+    <body>
+    <h1>Wesnoth NativeClient demo</h1>
+
+    <div id="nacl_div">
+    </div>
+    <canvas id="progress_bar"
+    width="1024" height="20">
+    Your browser does not support HTML5 Canvas.
+   </canvas>
+
+    <script src="wesnoth.js"></script>
+
+    <br />
+    Beware: saves are in-memory and are lost when the page is reloaded.
+
+  </body>
+</HTML>
diff --git a/wesnoth.js b/wesnoth.js
new file mode 100644
index 0000000..4157154
--- /dev/null
+++ b/wesnoth.js
@@ -0,0 +1,130 @@
+function updateProgressBar(percent, message, styleBackground,
+                           styleForeground, styleText) {
+    console.log("message: " + message);
+    console.log("progress: " + percent + "%");
+    var progress_bar =
+        document.getElementById('progress_bar');
+    var ctx = progress_bar.getContext('2d');
+    var width = progress_bar.width;
+    ctx.fillStyle = styleForeground ? styleForeground :
+        "rgb(200, 200, 200)";
+    ctx.fillRect(0, 0, percent * width, 20);
+    ctx.fillStyle = styleBackground ? styleBackground :
+        "#A9A9A9";  // From the css
+    ctx.fillRect(percent * width, 0, width, 20);
+    ctx.fillStyle = styleText ? styleText : "black";
+    ctx.textAlign = "center";
+    ctx.textBaseline = "middle";
+    ctx.font = 'sans-serif';
+    ctx.fillText(message, width / 2, 10, 3 * width / 4);
+}
+
+function HandleProgress(event) {
+    var loadPercent = 0.0;
+    var loadPercentString;
+    if (event.lengthComputable && event.total > 0) {
+        loadPercent = event.loaded / event.total;
+    } else {
+        // The total length is not yet known.
+        loadPercent = -1.0;
+    }
+    updateProgressBar(loadPercent, "Initializing Wesnoth (please be patient) ...");
+}
+
+function HandleMessage(event) {
+    console.log(event.data);
+    var data = JSON.parse(event.data);
+    updateProgressBar(data[1] / data[2], data[0]);
+}
+
+function updateStatusFail(message) {
+    updateProgressBar(1, message, 'black',
+                      'red', 'black')
+}
+
+function moduleLoadError() {
+    var msg = "NaCl module load error: " + document.getElementById('wesnoth').lastError;
+    updateStatusFail(msg);
+    console.log(msg);
+}
+
+function moduleLoadAbort() {
+    var msg = "NaCl module load aborted: " + document.getElementById('wesnoth').lastError;
+    updateStatusFail(msg);
+    console.log(msg);
+}
+
+function requestQuotaAndStartWesnoth() {
+    quota_required = 380*1024*1024;
+    window.webkitStorageInfo.requestQuota(PERSISTENT, quota_required, function(bytes) {
+            console.log("Persistent storage quota granted: " + bytes + " bytes");
+            if (bytes >= quota_required) {
+                var embed = document.createElement('embed');
+                embed.setAttribute('name', 'nacl_module');
+                embed.setAttribute('id', 'wesnoth');
+                embed.setAttribute('width', 1024);
+                embed.setAttribute('height', 800);
+                embed.setAttribute('src', 'wesnoth.nmf');
+                embed.setAttribute('type', 'application/x-nacl');
+                var div = document.getElementById("nacl_div");
+                div.appendChild(embed);
+                div.addEventListener('progress', HandleProgress, true);
+                div.addEventListener('message', HandleMessage, true);
+                div.addEventListener('error', moduleLoadError, true);
+                div.addEventListener('abort', moduleLoadAbort, true);
+            } else {
+                updateStatusFail("Unsufficient HTML5 file system quota: " + bytes + " bytes");
+                console.log("Unsufficient HTML5 file system quota: " + bytes + " bytes");
+            }
+        }, function(e) {
+            updateStatusFail("HTML5 file system quota request failed");
+            console.log("Quota request error: " + e);
+        });
+}
+
+
+function checkBrowser() {
+    var isValidBrowser = false;
+    var browserSupportStatus = 0;
+    var checker = new browser_version.BrowserChecker(15,  // Minumum Chrome version.
+                                                     navigator["appVersion"],
+                                                     navigator["plugins"]);
+    checker.checkBrowser();
+    isValidBrowser = checker.getIsValidBrowser();
+    browserSupportStatus = checker.getBrowserSupportStatus();
+    
+    switch (browserSupportStatus) {
+    case browser_version.BrowserChecker.StatusValues.NACL_ENABLED:
+        console.log('Native Client plugin enabled.');
+        break;
+    case browser_version.BrowserChecker.StatusValues.UNKNOWN_BROWSER:
+        updateStatusFail('UNKNOWN BROWSER');
+        break;
+    case browser_version.BrowserChecker.StatusValues.CHROME_VERSION_TOO_OLD:
+        console.log('Chrome too old: You must use Chrome version 15 or later.');
+        updateStatusFail('NEED CHROME 15 OR LATER');
+        break;
+    case browser_version.BrowserChecker.StatusValues.NACL_NOT_ENABLED:
+        console.log(
+                    'NaCl disabled: Native Client is not enabled.<br>' +
+                    'Please go to <b>chrome://plugins</b> and enable Native Client ' +
+                    'plugin.');
+        updateStatusFail('NativeClient NOT ENABLED');
+        break;
+    case browser_version.BrowserChecker.StatusValues.NOT_USING_SERVER:
+        console.log(
+                    'file: URL detected, please use a web server to host Native ' +
+                    'Client applications.');
+        updateStatusFail('file:// URLs NOT ALLOWED');
+    default:
+        console.log('Unknown error: Unable to detect browser and/or ' +
+                    'Native Client support.');
+        updateStatusFail('UNKNOWN ERROR');
+        break;
+    }
+    return isValidBrowser && browserSupportStatus == browser_version.BrowserChecker.StatusValues.NACL_ENABLED;
+}
+
+if (checkBrowser())
+    requestQuotaAndStartWesnoth();
+
